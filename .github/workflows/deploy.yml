name: Deploy Multi-School Next.js App

on:
  push:

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-east-1
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      ECR_REPO: "clockinclick"
      TERRAFORM_DIR: "terraform"

    steps:
      # Step 0: Checkout repo
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 1: Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # Step 2: Determine schools and workspace based on branch using secrets
      - name: Set schools based on branch
        run: |
          if [[ "${GITHUB_REF##*/}" == "main" ]]; then
            echo "SCHOOLS=${{ secrets.PROD_SCHOOLS }}" >> $GITHUB_ENV
            echo "WORKSPACE=production" >> $GITHUB_ENV
          else
            echo "SCHOOLS=${{ secrets.TEST_SCHOOLS }}" >> $GITHUB_ENV
            echo "WORKSPACE=testing" >> $GITHUB_ENV
          fi

      # Step 3: Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      # Step 4: Terraform init
      - name: Terraform Init
        run: terraform -chdir=${{ env.TERRAFORM_DIR }} init

      # Step 5: Create or ensure global ECR (only once, main branch)
      - name: Terraform Apply Global ECR
        if: github.ref == 'refs/heads/main'
        run: |
          terraform -chdir=${{ env.TERRAFORM_DIR }} apply \
            -auto-approve \
            -target=aws_ecr_repository.${ECR_REPO}

      # Step 6: Select or create Terraform workspace
      - name: Select Terraform workspace
        run: |
          terraform -chdir=${{ env.TERRAFORM_DIR }} workspace select $WORKSPACE || \
          terraform -chdir=${{ env.TERRAFORM_DIR }} workspace new $WORKSPACE
          echo "Using Terraform workspace: $WORKSPACE"

      # Step 7: Terraform apply environment-specific infra (DynamoDB + IAM)
      - name: Terraform Apply Environment Infra
        run: |
          # Convert comma-separated secret into a JSON-style list
          SCHOOLS_JSON=$(echo "[\"$(echo $SCHOOLS | sed 's/,/","/g')\"]")
          # Initialize an empty string for all targets
          TARGETS=""
      
          # Loop through schools and add the resource addresses dynamically
          for school in $SCHOOLS_JSON; do
          TARGETS="$TARGETS -target=module.schools${school}.aws_dynamodb_table.users"
          TARGETS="$TARGETS -target=module.schools${school}.aws_dynamodb_table.time_attendance"
          TARGETS="$TARGETS -target=module.schools${school}.aws_iam_role.apprunner_role"
          TARGETS="$TARGETS -target=module.schools${school}.aws_iam_policy.apprunner_policy"
          TARGETS="$TARGETS -target=module.schools${school}.aws_iam_role_policy_attachment.apprunner_role_attach"
          done
          
          terraform -chdir=${{ env.TERRAFORM_DIR }} apply \
            -auto-approve \
            -var="schools=${SCHOOLS_JSON}" \
            $TARGETS

      # Step 8: Login to ECR
      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      # Step 9: Build & push Docker images per school
      - name: Build and Push Docker Images
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          
          for school in $SCHOOLS; do
            SCHOOL_LOWER=$(echo "$school" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')
            IMAGE_URI="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${ECR_REPO}:${SCHOOL_LOWER}-latest"
          
            echo "üè´ Building and pushing Docker image for $school -> $IMAGE_URI"
          
            # --- 1Ô∏è‚É£ Retrieve secrets and create .env ---
            SECRET_NAME="clockinclick-app-secrets"   # adjust if your secret names differ
            echo "Fetching secrets for $SECRET_NAME from AWS Secrets Manager..."
          
            aws secretsmanager get-secret-value \
              --secret-id "$SECRET_NAME" \
              --region "${AWS_REGION}" \
              --query 'SecretString' \
              --output text > secrets.json
          
            jq -r 'to_entries | map("\(.key)=\(.value)") | .[]' secrets.json > .env.production
            rm secrets.json
            echo "‚úÖ .env file created for $school"
          
            # Append NEXTAUTH_URL based on school name
            NEXTAUTH_URL="https://$school.clockin.click"
            echo "NEXTAUTH_URL=$NEXTAUTH_URL" >> .env.production
          
            # Append SCHOOL_NAME based on school name
            SCHOOL_NAME=$school
            echo "SCHOOL_NAME=$SCHOOL_NAME" >> .env.production
         
            # --- 2Ô∏è‚É£ Download logo from S3 (optional overwrite) ---
            LOGO_KEY="$school/images/logo.png"
            LOGO_DEST="public/images/logo.png"
          
            echo "Attempting to download logo s3://clockinclick-school-assets/$LOGO_KEY"
            aws s3 cp "s3://clockinclick-school-assets/$LOGO_KEY" "$LOGO_DEST" \
              --region "${AWS_REGION}" \
              && echo "‚úÖ Custom logo found and applied for $school" \
              || echo "‚ÑπÔ∏è No custom logo found ‚Äî using fallback logo."
          
          
            # --- 3Ô∏è‚É£ Build & push Docker image ---
            docker build -t "$IMAGE_URI" ./
          
            docker push "$IMAGE_URI"
          
            echo "‚úÖ Finished building and pushing image for $school"
            echo ""
          done


      # Step 10: Terraform apply App Runner + Route 53
      - name: Terraform Apply App Runner + Route53
        run: |
          # Convert comma-separated secret into a JSON-style list
          SCHOOLS_JSON=$(echo "[\"$(echo $SCHOOLS | sed 's/,/","/g')\"]")
          # Initialize an empty string for all targets
          TARGETS=""
          
          # Loop through schools and add the resource addresses dynamically
          for school in $SCHOOLS_JSON; do
          TARGETS="$TARGETS -target=module.schools${school}.aws_apprunner_service.service"
          TARGETS="$TARGETS -target=module.schools${school}.aws_apprunner_custom_domain_association.domain"
          TARGETS="$TARGETS -target=module.schools${school}.aws_route53_record.school_subdomain"
          done
          
          terraform -chdir=${{ env.TERRAFORM_DIR }} apply \
            -auto-approve \
            -var="schools=${SCHOOLS_JSON}" \
            $TARGETS

      # Step 11: Terraform apply cert validation
      - name: Terraform Apply Certificate Validation
        run: |
          # Convert comma-separated secret into a JSON-style list
          SCHOOLS_JSON=$(echo "[\"$(echo $SCHOOLS | sed 's/,/","/g')\"]")
          # Initialize an empty string for all targets
          TARGETS=""
          
          # Loop through schools and add the resource addresses dynamically
          for school in $SCHOOLS_JSON; do
          TARGETS="$TARGETS -target=module.schools${school}.aws_route53_record.validation"
          done
          
          terraform -chdir=${{ env.TERRAFORM_DIR }} apply \
            -auto-approve \
            -var="schools=${SCHOOLS_JSON}" \
            $TARGETS